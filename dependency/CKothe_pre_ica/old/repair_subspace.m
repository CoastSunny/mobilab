function signal = repair_subspace(signal,stddev_cutoff,window_len,block_size,max_dimensions)
% Repairs local peak artifacts (such as generated by muscle activity) by interpolating the subspace.
% Signal = flt_repair_bursts(Signal,StandardDevCutoff,WindowLength,BlockSize)
%
% This is an automated artifact rejection function that ensures that the data contains no events
% that have abnormally strong power; the subspaces on which those events occur are reconstructed 
% (interpolated) based on the rest of the EEG signal during these time periods.
%
% Note that this function performs very local surgery: it is best applied after the hopeless windows 
% have already been removed using clean_windows.
%
% The way in which this is done is as follows: in a sliding window the PCA decomposition for the window 
% is computed; if there are large artifacts in this window, they will be captured quite reliably 
% by the largest few dimensions of the PCA. For each vector in the PCA eigenvector space it is checked
% whether the variance along the given direction is larger than some robustly determined threshold.
%
% Next, based on only the activity in the remaining (non-artifact) subspace of the observed data,
% the source activity of some latent pseudo/placeholder "sources" is computed (more later on these).
% Then, this restricted source activity estimate is back-projected onto all PCA dimensions, including
% the artifacts (thus, the formerly artifactual subspace are interpolated based on some conservative 
% brain-source activity estimates). The result is then rotated back from PCA space into channel space.
%
% The placeholder source model (i.e. mixing matrix) is computed on a very clean portion of the data
% to be maximally unaffected by burst activity.
%
% In:
%   Signal          : continuous data set, assumed to be appropriately high-passed (e.g. >0.5Hz or
%                     with a 0.5Hz - 2.0Hz transition band)
%
%   StandardDevCutoff: StdDev cutoff for rejection. Data segments whose variance is beyond this cutoff 
%                      from the distribution of variance across the recording are considered missing data.
%                      (default: 3)
%
%   WindowLength    : length of the windows (in seconds) for which the power is computed, i.e. the 
%                     granularity of the measure; ideally short enough to reasonably isolate
%                     artifacts, but no shorter (for computational reasons) (default: 0.5)
%
%   BlockSize       : Block granularity for processing. The reprojection matrix will be updated every 
%                     this many samples and a blended matrix is used for the in-between samples.
%                     (default: 32)
%
%   MaxDimensions   : Maximum dimensionality to reconstruct. Up to this many dimensions (or up to 
%                     this fraction of dimensions) can be reconstructed for a given data segment. This is 
%                     since the lower eigenvalues are usually not estimated very well. (default: 0.5)
%
% Out:
%   Signal : data set with local peaks removed
%
% Examples:
%   % use the defaults
%   eeg = flt_repair_bursts(eeg);
%
%                                Christian Kothe, Swartz Center for Computational Neuroscience, UCSD
%                                2010-07-10

if ~exist('stddev_cutoff','var') || isempty(stddev_cutoff) stddev_cutoff = 3; end
if ~exist('window_len','var') || isempty(window_len) window_len = 0.5; end
if ~exist('block_size','var') || isempty(block_size) block_size = 32; end
if ~exist('max_dimensions','var') || isempty(max_dimensions) max_dimensions = 0.5; end

fprintf('Now repairing (this may take a while)...');

mem_quota = 0.25;                   % maximum fraction of free memory that may be claimed by this function
coeff = [0.1314,-0.2877,-0.0104];   % coefficients that model the degrees of freedom in the EEG covariance chi^2 distribution
                                    % depending on the window length over which the covariances are calculated

% get rid of NaN's and Inf's
signal.data(~isfinite(signal.data(:))) = 0;
                                    
% number of data points for our sliding window (N) and look-ahead (P)
N = round(window_len * signal.srate); %#ok<*NODEF>
P = round(N/2);
if size(signal.data,2) < N+1
    error(['The data set needs to be longer than the statistics window length (for this data set ' num2str(window_len) ' seconds).']); end

[C,S] = size(signal.data); %#ok<*NODEF>
wnd = 0:N-1;
offsets = 1 + floor(0:N:S-N);
W = length(offsets);

% --- computing initial statistics ---

% first and second order filter conditions and signal offset for better numeric conditioning
state = struct('ord1',[],'ord2',[],'offset',sum(signal.data,2)/size(signal.data,2));

% for each data segment...
wndcovs = zeros(C,C,length(offsets));
wndchols = zeros(C*C,length(offsets));
for o=1:W
    T = signal.data(:,offsets(o) + wnd)';
    wndcov = cov(T);
    % store its covariance matrix
    wndcovs(:,:,o) = wndcov;
    % store its Cholesky decomposition
    wndchol = eye(C);
    tmp = cholcov(wndcov); wndchol(1:size(tmp,1),1:size(tmp,2)) = tmp;
    wndchols(:,o) = reshape(wndchol,C*C,1);
end

% take their geometric median and map it back into covariance space
medchol = reshape(l1_median(reshape(wndchols,C*C,W)'),C,C);
state.medcov = medchol'*medchol;
% and also get a mixing matrix from it
state.mixing = sqrtm(state.medcov);

% rescale it to compensate for under-estimation of the true covariance matrices
vars = zeros(C,length(offsets));
for o=1:W
    vars(:,o) = diag(wndcovs(:,:,o)); end
state.medcov = state.medcov * diag(median(vars,2) ./ diag(state.medcov));
% and do another pass using random projections to get the off-diagonal elements right
rot = get_orthonormal(C);
for o=1:W
    vars(:,o) = diag(rot' * wndcovs(:,:,o) * rot); end
rescaling = diag(median(vars,2) ./ diag(rot'*state.medcov*rot));
% apply (rotate - scale - rotate back)
state.medcov = rot' * state.medcov * rot;
state.medcov = state.medcov * rescaling;
state.medcov = rot * state.medcov * rot';

% --- actual processing ---

% prepend and append a mirrored signal as padding 
signal.data = [repmat(2*signal.data(:,1),1,N) - signal.data(:,(N+1):-1:2) signal.data repmat(2*signal.data(:,end),1,N) - signal.data(:,(end-N):(end-1))];
% and update the signal length to include the initial padding
S = S+N;

% the recovery mask protects lower eigenvectors from being reconstructed
if max_dimensions < 1
    max_dimensions = round(C*max_dimensions); end
recovery_mask = (1:C)' < (C-max_dimensions);

% split up the total sample range into k chunks that will fit in memory
if S > 1000
    free_mem = java.lang.management.ManagementFactory.getOperatingSystemMXBean().getFreePhysicalMemorySize();
    numsplits = ceil((C^2*S*8*5) / (free_mem*mem_quota));
else
    numsplits = 1;
end

eye_mat = eye(size(signal.data,1));
for i=0:numsplits-1
    range = 1+floor(i*S/numsplits) : min(S,floor((i+1)*S/numsplits));
    if ~isempty(range)
        % get raw data X to compute statistics over (range is shifted by the amount of look-ahead P)
        X = double(bsxfun(@minus,signal.data(:,range+P),state.offset));
        % ... and running mean E[X]
        [Xmean,state.ord1] = moving_average(N,X,state.ord1,2);
        % get unfolded cross-terms tensor X*X'
        [m,n] = size(X); X2 = reshape(bsxfun(@times,reshape(X,1,m,n),reshape(X,m,1,n)),m*m,n);
        % ... and running mean of that E[X*X']
        [X2mean,state.ord2] = moving_average(N,X2,state.ord2,2);
        % compute running covariance E[X*X'] - E[X]*E[X]'
        Xcov = X2mean - reshape(bsxfun(@times,reshape(Xmean,1,m,n),reshape(Xmean,m,1,n)),m*m,n);
        
        % we update the reprojection matrix every block_size samples
        update_at = 1:block_size:size(Xcov,2);
        if update_at(end) < size(Xcov,2)
            update_at(end+1) = size(Xcov,2); end %#ok<AGROW>
        
        last_n = 0;
        last_matrix = eye_mat;
        last_flagged = false;
        % for each position in the statistics buffer for which we update the re-projection matrix...
        for n=update_at
            % calculate an eigenvector decomposition
            [V,D] = eig(reshape(Xcov(:,n),m,m));
            % get the median of the segment amplitudes for each eigenvector in V
            amp_median = sqrt(diag(V'*state.medcov*V));
            % and estimate their median absolute deviation based on the median (depends on the # of
            % degrees of freedom of the chi-squared distribution underlying the amplitudes)
            amp_mad = amp_median .* (coeff(1)*window_len^coeff(2) + coeff(3));
            % retain only those spatial components whose amplitude is within k standard deviations
            mask = (sqrt(diag(D))-amp_median < amp_mad * stddev_cutoff) | recovery_mask;
            if ~all(mask)
                % we have some rejections; first rotate the mixing matrix into the eigenspace
                mixing_eig = (V'*state.mixing);
                % generate a re-construction matrix with this subspace interpolated from the rest...
                mixing_eig_trunc = mixing_eig; mixing_eig_trunc(~mask,:) = 0;
                % 3. rotate back <-- 2. apply reconstruction in this space based on the mixing matrix when transformed into this space <-- 1. rotate data into eigenspace
                reconstruct = V * (mixing_eig*pinv(mixing_eig_trunc)) * V';
                flagged = true;
            else
                % nothing to do
                reconstruct = eye_mat;
                flagged = false;
            end
            if flagged || last_flagged
                % apply the reconstruction to the samples range since the last update position
                update_range = (last_n+1):n;
                % ... using the following Hann window blend weights
                wts = (update_range - last_n) / (n - last_n);
                wts = 0.5*(1-cos(pi*wts));
                for k=1:length(update_range)
                    signal.data(:,range(last_n+k)) = ((1-wts(k))*last_matrix + wts(k)*reconstruct) * signal.data(:,range(last_n+k)); end                
            end
            last_matrix = reconstruct;
            last_flagged = flagged;
            last_n = n;
        end
    end
end

% trim the padding
signal.data(:,[1:N (end-N+1):end]) = [];

fprintf('done.');


function [X,Zf] = moving_average(N,X,Zi,dim)
% Like filter() for the special case of moving-average kernels.
% [X,Zf] = moving_average(N,X,Zi,Dim)
%
% In:
%   N : filter length in samples
%
%   X : data matrix
%
%   Zi : initial filter conditions (default: [])
%
%   Dim : dimension along which to filter (default: first non-singleton dimension)
%
% Out:
%   X : the filtered data
%
%   Zf : final filter conditions
%
% See also:
%   filter
%
%                                Christian Kothe, Swartz Center for Computational Neuroscience, UCSD
%                                2012-03-05

% determine the dimension along which to filter
if nargin <= 3
    if isscalar(X)
        dim = 1;
    else
        dim = find(size(X)~=1,1); 
    end
end

% empty initial state
if nargin <= 2
    Zi = []; end

lenx = size(X,dim);
if lenx == 0
    % empty X
    Zf = Zi;
else
    if N < 100
        % small N: use filter
        [X,Zf] = filter(ones(N,1)/N,1,X,Zi,dim);
    else
        % we try to avoid permuting dimensions below as this would increase the running time by ~3x
        if ndims(X) == 2
            if dim == 1
                % --- process along 1st dimension ---
                if isempty(Zi)
                    % zero initial state
                    Zi = zeros(N,size(X,2));
                elseif size(Zi,1) == N-1
                    % reverse engineer filter's initial state (assuming a moving average)
                    tmp = diff(Zi(end:-1:1,:),1,1);
                    Zi = [tmp(end:-1:1,:); Zi(end,:)]*N;
                    Zi = [-sum(Zi,1); Zi];
                elseif ~isequal(size(Zi),[N,size(X,2)])
                    error('These initial conditions do not have the correct format.');
                end
                
                % pre-pend initial state & get dimensions
                Y = [Zi; X]; M = size(Y,1);
                % get alternating index vector (for additions & subtractions)
                I = [1:M-N; 1+N:M];
                % get sign vector (also alternating, and includes the scaling)
                S = [-ones(1,M-N); ones(1,M-N)]/N;
                % run moving average
                X = cumsum(bsxfun(@times,Y(I(:),:),S(:)),1);
                % read out result
                X = X(2:2:end,:);
                
                % construct final state
                if nargout > 1
                    Zf = [-(X(end,:)*N-Y(end-N+1,:)); Y(end-N+2:end,:)]; end
            else
                % --- process along 2nd dimension ---
                if isempty(Zi)
                    % zero initial state
                    Zi = zeros(N,size(X,1));
                elseif size(Zi,1) == N-1
                    % reverse engineer filter's initial state (assuming a moving average)
                    tmp = diff(Zi(end:-1:1,:),1,1);
                    Zi = [tmp(end:-1:1,:); Zi(end,:)]*N;
                    Zi = [-sum(Zi,1); Zi];
                elseif ~isequal(size(Zi),[N,size(X,1)])
                    error('These initial conditions do not have the correct format.');
                end
                
                % pre-pend initial state & get dimensions
                Y = [Zi' X]; M = size(Y,2);
                % get alternating index vector (for additions & subtractions)
                I = [1:M-N; 1+N:M];
                % get sign vector (also alternating, and includes the scaling)
                S = [-ones(1,M-N); ones(1,M-N)]/N;
                % run moving average
                X = cumsum(bsxfun(@times,Y(:,I(:)),S(:)'),2);
                % read out result
                X = X(:,2:2:end);
                
                % construct final state
                if nargout > 1
                    Zf = [-(X(:,end)*N-Y(:,end-N+1)) Y(:,end-N+2:end)]'; end
            end
        else
            % --- ND array ---
            [X,nshifts] = shiftdim(X,dim-1);
            shape = size(X); X = reshape(X,size(X,1),[]);
            
            if isempty(Zi)
                % zero initial state
                Zi = zeros(N,size(X,2));
            elseif size(Zi,1) == N-1
                % reverse engineer filter's initial state (assuming a moving average)
                tmp = diff(Zi(end:-1:1,:),1,1);
                Zi = [tmp(end:-1:1,:); Zi(end,:)]*N;
                Zi = [-sum(Zi,1); Zi];
            elseif ~isequal(size(Zi),[N,size(X,2)])
                error('These initial conditions do not have the correct format.');
            end
            
            % pre-pend initial state & get dimensions
            Y = [Zi; X]; M = size(Y,1);
            % get alternating index vector (for additions & subtractions)
            I = [1:M-N; 1+N:M];
            % get sign vector (also alternating, and includes the scaling)
            S = [-ones(1,M-N); ones(1,M-N)]/N;
            % run moving average
            X = cumsum(bsxfun(@times,Y(I(:),:),S(:)),1);
            % read out result
            X = X(2:2:end,:);
            
            % construct final state
            if nargout > 1
                Zf = [-(X(end,:)*N-Y(end-N+1,:)); Y(end-N+2:end,:)]; end
            
            X = reshape(X,shape);
            X = shiftdim(X,ndims(X)-nshifts);
        end
    end
end


function mX = l1_median(X,tol)
% L1MEDIAN calculates the multivariate L1 median 
% I/O: [mX]=L1median(X,tol);
%
% X is the data matrix 
% tol is the convergence criterium; the iterative proces stops when ||m_k - m_{k+1}|| < tol.
%
% Ref: Hossjer and Croux (1995) "Generalizing Univariate Signed Rank Statistics for Testing
% and Estimating a Multivariate Location Parameter", Non-parametric Statistics, 4, 293-308.
% Translated from the Gauss code of Hossjer and Croux (1995) in matlab by Sabine Verboven, Antwerp University. 

if nargin <2
   tol=1.e-08;
end;
[n,p]=size(X);
maxstep=200;
%initializing starting value for m
m=median(X);
k=1;
while (k<=maxstep)
   mold=m;
   Xext=sortrows([norme(X-repmat(m,n,1)) X],1);
   dx=Xext(:,1);
   X=Xext(:,2:p+1);
   if all(dx)
      w=1./dx;
   else
      ww=dx(all(dx,2));
      w=1./ww;
      w=[zeros(length(dx)-length(w),1);w];
   end
   delta=sum((X-repmat(m,n,1)).*repmat(w,1,p),1)./sum(w);
   nd=norme(delta);
   if all(nd<tol)
      maxhalf=0;
   else
      maxhalf=log2(nd/tol);
   end
	m=mold+delta;   %computation of a new estimate
   nstep=0;
   while all(mrobj(X,m)>=mrobj(X,mold))&(nstep<=maxhalf)
      nstep=nstep+1;
      m=mold+delta./(2^nstep);
   end
   if (nstep>maxhalf)
      mX=mold;
      break
   end
   k=k+1;
end
if k>maxstep
   display('Iteration failed')
end
mX=m;

function n=norme(X)
n = sqrt(sum(X.^2,2));

function s=mrobj(X,m)
xm=norme(X-repmat(m,size(X,1),1));
s=sum(xm,1)';


function answer = get_orthonormal(m,n)
% Produces an m x n set of orthonormal vectors, 
% (thats n vectors, each of length m)
if ( (nargin==2) && (m>n) && (isnumeric(m)*isnumeric(n)) )
elseif ( nargin==1 && isnumeric(m) && length(m)==1 )
    n=m;    
else
   error('Incorrect Inputs. Please read help text in m-file.')
end
count=0;
while (count==0)
    % generate an mxm matrix A, then make a symmetric mxm matrix B
    A=rand(m);
    B=A'*A ;
    [P,D] = eig(B) ;
    if ((P'*P - eye(m))>eps) 
        count=0;
    else
        answer=P(:,1:n) ;
        count=1;
    end
end
